<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TPB DB Serverless Client</title>
</head>
<body>

<div style="text-align: center">
    <p>This is a simple page that provides you convenient search access to the static <a href="https://github.com/klesun-misc/piratebay-db-dump">200 MiB CSV</a> list of torrents referenced in this repo</p>

    <div>
        <form onsubmit="alert('Please wait for torrent list to load!'); return false;">
            <div style="margin: 8px">
                <input type="text" name="nameSubstring" placeholder="type part of file name here..."/>
                <button class="update-results-btn">Search</button>
            </div>
            <div>
                <label>
                    <span>Hide Offensive: </span>
                    <input name="hideOffensiveFlag" type="checkbox" checked="checked"/>
                </label>
                <label>
                    <span>Hide Unresponsive: </span>
                    <input name="hideUnresponsiveFlag" type="checkbox" checked="checked"/>
                </label>
                <label>
                    <span>Regex: </span>
                    <input name="useRegex" type="checkbox"/>
                    <a href="https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285#0090">ref</a>
                </label>
                <label>
                    <span>Limit Per Page: </span>
                    <input type="number" name="maxEntriesPerPage" min="1" max="50000" value="750"/>
                </label>
            </div>
        </form>
    </div>

    <p id="status-panel">Please wait, loading libs...</p>
</div>

<div>
    <table style="margin: 0 auto">
        <thead>
            <tr>
                <th data-name="addedDt">Added</th>
                <th data-name="infohash">Infohash (Download Link)</th>
                <th data-name="name">Name</th>
                <th data-name="size">Size</th>
                <th data-name="status">Status</th>
            </tr>
        </thead>
        <tbody id="matched-entries-list"></tbody>
    </table>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"
        integrity="sha512-rKFvwjvE4liWPlFnvH4ZhRDfNZ9FOpdkD/BU5gAIA3VS3vOQrQ5BjKgbO3kxebKhHdHcNUHLqxQYSoxee9UwgA=="
        crossorigin="anonymous"></script>

<script type="module">
    import {Dom} from "./web_client/Dom.js";

    const Papa = window.Papa;

    const escapeRegex = (str) => str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");

    /** @see https://stackoverflow.com/a/39460727/2750743 */
    function base64ToHex(str) {
      const raw = atob(str);
      let result = '';
      for (let i = 0; i < raw.length; i++) {
        const hex = raw.charCodeAt(i).toString(16);
        result += (hex.length === 2 ? hex : '0' + hex);
      }
      return result.toUpperCase();
    }

    /** @param {RegExp} reg */
    const getRegexIterator = function*(superstring, reg) {
        let match;
        const statefulRegex = new RegExp(reg);
        while (match = statefulRegex.exec(superstring)) {
            yield match.index;
        }
    }

    const parseRowAt = (csvText, index) => {
        const prevBr = csvText.lastIndexOf('\n', index);
        const start = prevBr === -1 ? 0 : prevBr + 1;
        const nextBr = csvText.indexOf('\n', index);
        const end = nextBr === -1 ? csvText.length : nextBr;

        const line = csvText.slice(start, end);
        if (line.trim() === '') {
            return null;
        }

        const parsed = Papa.parse(line, {delimiter: ';'});
        const valuesTuple = parsed.data[0];

        return valuesTuple;
    };

    const gui = {
        statusPanel: document.getElementById('status-panel'),
        searchForm: document.forms[0],
        matchedEntriesList: document.getElementById('matched-entries-list'),
    };

    let bytesLoaded = 0;
    const csvFetchStartMs = Date.now();
    const trackBytesLoaded = rs => {
        const reader = rs.body.getReader();
        const stream = new ReadableStream({
            start(controller) {
                const pump = () => {
                    return reader.read().then(({ done, value }) => {
                        if (done) {
                            controller.close();
                        } else {
                            bytesLoaded += value.length;
                            gui.statusPanel.textContent = 'Bytes Loaded: ' + (bytesLoaded / 1024 / 1024).toFixed(3) + ' MiB / ~200 MiB in ' + (Date.now() - csvFetchStartMs) + ' ms';
                            controller.enqueue(value);
                            return pump();
                        }
                    });
                };
                return pump();
            },
        });
        return new Response(stream);
    };

    const offensiveRegexes = [
        'fuck', 'fucks', 'fucked', 'fucker', 'cum', 'cums', 'nude', 'nudes', 'pussy', 'pussies', 'playboy', 'sex', 'XXX', 'anal', 'rape', 'raped', 'rapes',
        'glory hole', 'gloryHole', 'porn', 'porns', 'uncensored', 'penis', 'penises', 'dick', 'dicks', 'cock', 'dildo', 'erotic',
        /*'hentai', moshiboroshihujoshi titles would not offend anyone I think*/
    ].flatMap(word => {
        const capitalized = word.charAt(0).toUpperCase() + word.slice(1);
        const anyCaseRegex = new RegExp('\\b' + escapeRegex(word) + '\\b', 'i');
        const capitalizedRegex = new RegExp('([a-z0-9_]|\\b)' + escapeRegex(capitalized) + '([A-Z0-9_]|\\b)');
        return [anyCaseRegex, capitalizedRegex];
    });

    const isOffensive = (torrentName) => {
        return offensiveRegexes.some(regex => torrentName.match(regex));
    };

    gui.statusPanel.textContent = 'Retrieving CSV (~200 MiB)...\n';

    const urlToCsvTextPromise = url => fetch(url)
        .then(trackBytesLoaded)
        .then(rs => rs.text());

    const halfPromise = urlToCsvTextPromise('./piratebay_db_dump_2015_10_27T04_10_50_to_2019_09_14T22_09_31.csv');
    const secondPromise = halfPromise.then(() => urlToCsvTextPromise('./piratebay_db_dump_2004_03_25T22_03_00_to_2015_10_27T04_10_22.csv'));

    const csvTextPromises = [
        urlToCsvTextPromise('./random_torrent_contributions.csv'),
        halfPromise,
        secondPromise,
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_2.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_8.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_9.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_10.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_11.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_18.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_19.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_20.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_22.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_23.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_24.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_25.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_26.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_28.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_29.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_31.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_33.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_34.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_35.csv',)),
        secondPromise.then(() => urlToCsvTextPromise('./rutracker_2020_09_27/category_37.csv',)),
    ];

    // could potentially allow searching without waiting for full data
    // to load... will need to integrate with ReadableStream more tightly then

    const fetchedCsvTexts = [];
    csvTextPromises.forEach(promise => promise.then(csvText => {
        document.body.classList.toggle('results-outdated', true);
        fetchedCsvTexts.push(csvText);
    }));

    const updateTable = ({csvText, tbody, maxEntries, regex, namePred}) => {
        let matchesFound = 0;

        const colsBr = csvText.indexOf('\n');
        const indexesIter = getRegexIterator(csvText, regex);

        for (const index of indexesIter) {
            const valuesTuple = parseRowAt(csvText, index + 1);
            if (!valuesTuple) {
                continue; // empty lines in CSV, trailing line break for example
            }
            if (index < colsBr) {
                continue; // column headers matched the pattern
            }
            const [addedDt, infohashBase64, name, size] = valuesTuple;
            if (!namePred(name)) {
                continue;
            }

            const infoHash = base64ToHex(infohashBase64);
            const statusHolder = Dom('div', {class: 'status-holder', style: 'font-size: 12px'});

            const tr = Dom('tr', {}, [
                Dom('td', {'data-name': 'addedDt'}, addedDt),
                Dom('td', {'data-name': 'infohash'}, [
                    Dom('a', {'href': 'magnet:?xt=urn:btih:' + infoHash}, [
                        Dom('span', {}, 'ðŸ§² '),
                    ]),
                    Dom('a', {'href': 'magnet:?xt=urn:btih:' + infoHash}, [
                        Dom('span', {class: 'info-hash-text'}, infoHash),
                    ]),
                ]),
                // would be nice to highlight the part of text that was matched
                Dom('td', {'data-name': 'name'}, name),
                Dom('td', {'data-name': 'size'}, (size / 1024 / 1024).toFixed(3) + ' MiB'),
                Dom('td', {'data-name': 'status'}, [statusHolder]),
                // TODO: add here "Watch" button that redirects to the respective kunkka-torrent page
            ]);
            tbody.appendChild(tr);
            if (++matchesFound >= maxEntries) {
                break;
            }
        }

        return {matchesFound};
    };

    const prepareUpdateParams = (csvText, totalMatchesFound) => {
        const tbody = gui.matchedEntriesList;
        const nameSubstring = gui.searchForm['nameSubstring'].value.trim();
        const totalMaxEntries = +gui.searchForm['maxEntriesPerPage'].value;

        if (nameSubstring) {
            document.body.classList.toggle('first-search-submitted', true);
            document.body.classList.toggle('results-outdated', false);
        }

        const regSrc = nameSubstring
            ? gui.searchForm['useRegex'].checked
                ? nameSubstring
                : nameSubstring.split(' ')
                    .map(escapeRegex)
                    .join('[\ \_\.]')
            : '\\n';
        let regex;
        try {
            regex = new RegExp(regSrc, 'ig');
        } catch (exc) {
            alert('Invalid regex format - ' + exc);
            throw exc;
        }
        const maxEntries = totalMaxEntries - totalMatchesFound;
        const namePred = name => {
            // ignore if text search matched the hex string
            const matchedWrongValue = nameSubstring && !name.match(regex);
            const hideAsOffensive = gui.searchForm['hideOffensiveFlag'].checked && isOffensive(name);
            return !matchedWrongValue && !hideAsOffensive;
        };
        return {
            csvText, tbody, maxEntries, regex, namePred,
        };
    };

    halfPromise.then(async firstCsvText => {
        const tbody = gui.matchedEntriesList;
        gui.searchForm.onsubmit = (evt) => {
            evt.preventDefault();
            tbody.innerHTML = '';
            let totalMatchesFound = 0;
            for (const csvText of fetchedCsvTexts) {
                const params = prepareUpdateParams(csvText, totalMatchesFound);
                const {matchesFound} = updateTable(params);
                totalMatchesFound += matchesFound;
                if (matchesFound >= params.maxEntries) {
                    break;
                }
            }
            gui.statusPanel.textContent = 'Found ' + totalMatchesFound + ' matches\n';
            [...tbody.children].slice(0, 200).forEach(tr => {
                const infoHash = tr.querySelector('.info-hash-text').textContent;
                const statusHolder = tr.querySelector('.status-holder');
                fetch('https://kunkka-torrent.online/api/checkInfoHashMeta?infoHash=' + infoHash)
                    .then(rs => rs.status === 200 ? rs.json() : Promise.reject(rs.statusText))
                    .then(data => Dom('div', {}, [
                        Dom('span', {}, 'File List:'),
                        Dom('input', {type: 'checkbox', class: 'hide-following-flag'}),
                        Dom('table', {}, [
                            Dom('thead', {}, [
                                Dom('tr', {}, [
                                    Dom('th', {}, data.name),
                                    Dom('th', {}, data.length),
                                ]),
                            ]),
                            Dom('tbody', {}, data.files.map(f => Dom('tr', {}, [
                                Dom('td', {}, f.path),
                                Dom('td', {}, f.length),
                            ]))),
                        ]),
                    ]))
                    .catch(exc => {
                        if ((exc + '').includes('Promise timed out')) {
                            tr.classList.toggle('meta-info-timed-out');
                        }
                        return Dom('span', {}, 'Err: ' + exc);
                    })
                    .then(content => statusHolder.appendChild(content));

            });
        };
        // gosh, so much porn, make sure to never allow user to enter less than 3 characters long query
        // upd.: added bad words filtering, results seem to be more or less ok now
        // nameSubstring = nameSubstring.length >= 3 ? nameSubstring : '264';
        const params = prepareUpdateParams(firstCsvText, 0);
        updateTable(params);
    });

    const searchInput = gui.searchForm['nameSubstring'];
    const checkRegexSyntax = () => {
        if (gui.searchForm['useRegex'].checked) {
            try {
                let regex = new RegExp(searchInput.value);
                'some random text'.match(regex);
                searchInput.setCustomValidity(''); // valid
                searchInput.title = '';
            } catch (exc) {
                let error = exc + '';
                searchInput.setCustomValidity(error); // invalid
                searchInput.title = error;
            }
        } else {
            searchInput.setCustomValidity('');
        }
    };
    searchInput.addEventListener('input', checkRegexSyntax);
    gui.searchForm['useRegex'].addEventListener('change', checkRegexSyntax);
    gui.searchForm['hideUnresponsiveFlag'].onchange = () => {
        document.body.classList.toggle('hide-unresponsive', gui.searchForm['hideUnresponsiveFlag'].checked);
    };
    gui.searchForm['hideUnresponsiveFlag'].onchange();
</script>

</body>

<style>
    #status-panel {
        white-space: pre;
    }

    table {
        border-collapse: collapse;
    }
    td, th {
        padding: 4px 8px
    }
    tr {
        border-bottom: solid 1px #d6d6d6;
    }

    th[data-name="addedDt" ] { min-width: 140px; }
    th[data-name="infohash"] { min-width: 240px; }
    th[data-name="name"    ] { min-width: 140px; }
    th[data-name="size"    ] { min-width: 120px; }

    td[data-name="infohash"] {
        white-space: nowrap;
    }
    td[data-name="addedDt"] {
        text-transform: lowercase;
        white-space: nowrap;
    }
    td[data-name="size"] {
        text-align: right;
    }
    td[data-name="name"] {
        max-width: 400px;
        overflow-wrap: break-word;
    }
    label {
        margin: 8px;
        padding: 4px;
        border: solid #bdbdbd 1px;
        background-color: #f9f9f9;
    }
    label:hover {
        border-color: #529ae7;
    }
    body.first-search-submitted.results-outdated .update-results-btn {
        box-shadow: 0px 0px 8px 4px #1875ff;
    }
    [name="nameSubstring"]:invalid {
        box-shadow: 0px 0px 2px 2px red;
    }
    .hide-following-flag:not(:checked) + * {
        display: none;
    }
    body.hide-unresponsive .meta-info-timed-out {
        display: none;
    }
</style>

</html>